<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>Mapa — Construcción de Grafo Bogotá</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

<style>
html, body { height:100%; margin:0; }
#map { width:100%; height:100vh; }

.control-box {
    position:absolute;
    top:20px;
    left:20px;
    z-index:1000;
    background:white;
    padding:10px;
    border-radius:6px;
    box-shadow:0 2px 6px rgba(0,0,0,0.24);
    width:300px;
    font-family:Arial;
    font-size:13px;
}

#pesoBox { display:none; margin-top:8px; }
#selectedPair { font-size:12px; font-weight:bold; margin-bottom:6px; }
#outputJson { width:100%; height:160px; font-family:monospace; font-size:11px; }
</style>
</head>

<body>

<div class="control-box">
    <div style="font-weight:bold;margin-bottom:6px;">Construcción de grafo</div>

    <button id="resetGrafo" style="width:100%;padding:6px;background:#aa0000;color:white;border:none;border-radius:4px;cursor:pointer;">
        Reiniciar Grafo
    </button>

    <div id="pesoBox">
        <div id="selectedPair"></div>
        <input type="number" id="inputPeso" placeholder="Peso de arista"
            style="width:100%;padding:6px;border:1px solid #bbb;border-radius:4px;margin-bottom:6px;">
        <button id="guardarEdge" style="width:100%;padding:6px;background:#0055aa;color:white;border:none;border-radius:4px;cursor:pointer;">
            Guardar arista
        </button>
        <button id="cancelEdge" style="width:100%;padding:6px;margin-top:5px;background:#888;color:white;border:none;border-radius:4px;cursor:pointer;">
            Cancelar
        </button>
    </div>

    <hr style="margin:10px 0;">
    <div style="font-weight:bold;margin-bottom:4px;">Grafo JSON</div>
    <textarea id="outputJson" readonly></textarea>

    <button id="sendGraph" style="width:100%;padding:6px;margin-top:10px;background:#228800;color:white;border:none;border-radius:4px;cursor:pointer;">
        Enviar grafo y calcular camino óptimo
    </button>

    <div id="serverResponse" style="margin-top:10px;font-size:12px;color:#333;"></div>
</div>

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>

const CAPACIDAD_POR_TIPO = {
  TRONCAL: 200,
  URBANO: 80,
  ALIMENTADOR: 60,
  METRO: 500,
  MIXTO: 120,
  UNKNOWN: 50
};

const map = L.map('map').setView([4.65, -74.1], 12);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {maxZoom:19}).addTo(map);

const capaSubgrafo = L.layerGroup().addTo(map);
const capaEstaciones = L.layerGroup().addTo(map);



const grafo = { nodos:{}, aristas:{} };

let origen = null;
let destino = null;

let selA = null;   
let selB = null;



function colorPorTipo(tipo) {
    tipo = (tipo || "").toUpperCase();
    if (tipo === "TRONCAL") return "red";
    if (tipo === "URBANO") return "blue";
    if (tipo === "ALIMENTADOR") return "green";
    if (tipo === "METRO") return "purple";
    return "gray";
}

function actualizarJson() {
    document.getElementById("outputJson").value = JSON.stringify(grafo, null, 2);
}


document.getElementById("resetGrafo").addEventListener("click", () => {
    grafo.nodos = {};
    grafo.aristas = {};
    origen = null;
    destino = null;
    selA = null;
    selB = null;

    capaSubgrafo.clearLayers();
    actualizarJson();
});



let estacionesById = {};

fetch("estaciones.geojson")
.then(r => r.json())
.then(data => {
    data.features.forEach(f => {
        const p = f.properties;
        const [lng, lat] = f.geometry.coordinates;
        const tipo = (p.tipo || "UNKNOWN").toUpperCase();

        estacionesById[p.stop_id] = { lat, lng, tipo };

        L.circleMarker([lat, lng], {
            radius:5,
            color:colorPorTipo(tipo),
            fillColor:colorPorTipo(tipo),
            fillOpacity:0.9
        })
        .bindPopup(`<b>${p.stop_name}</b><br>Tipo: ${tipo}`)
        .addTo(capaEstaciones);
    });
});



map.on("click", (e) => {


    let mejor = null;
    let menorDist = Infinity;

    for (const id in estacionesById) {
        const n = estacionesById[id];
        const dx = e.latlng.lat - n.lat;
        const dy = e.latlng.lng - n.lng;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist < menorDist && dist < 0.02) {
            menorDist = dist;
            mejor = id;
        }
    }

    if (!mejor) return;

    const nodo = estacionesById[mejor];


    if (!grafo.nodos[mejor]) {
        grafo.nodos[mejor] = {
            lat: nodo.lat,
            lng: nodo.lng,
            tipo: nodo.tipo,
            capacidad: CAPACIDAD_POR_TIPO[nodo.tipo] || 50
        };
        grafo.aristas[mejor] = [];
    }


    L.circleMarker([nodo.lat, nodo.lng], {
        radius:6,
        color:"black",
        fillColor:colorPorTipo(nodo.tipo),
        fillOpacity:1
    }).addTo(capaSubgrafo);


    if (!origen) {
        origen = mejor;
        document.getElementById("selectedPair").innerText = `Origen seleccionado: ${origen}`;
        return;
    }

    if (!destino) {
        if (mejor === origen) return; 
        destino = mejor;
        document.getElementById("selectedPair").innerText = `Origen: ${origen} → Destino: ${destino}`;
        return;
    }



    if (!selA) { 
        selA = mejor; 
        return; 
    }

    if (!selB && mejor !== selA) {
        selB = mejor;


        const box = document.getElementById("pesoBox");
        box.setAttribute("desde", selA);
        box.setAttribute("hasta", selB);
        box.style.display = "block";

        document.getElementById("selectedPair").innerText = `Arista: ${selA} → ${selB}`;
        return;
    }

    actualizarJson();
});



document.getElementById("guardarEdge").addEventListener("click", () => {

    const box = document.getElementById("pesoBox");
    const from = box.getAttribute("desde");
    const to = box.getAttribute("hasta");

    const peso = Number(document.getElementById("inputPeso").value);
    if (!peso || peso <= 0) {
        alert("Peso inválido");
        return;
    }

    const capDest = grafo.nodos[to].capacidad;
    const pesoReal = Math.min(peso, capDest);

    grafo.aristas[from].push({
        to,
        peso: pesoReal,
        coordinates: [
            [grafo.nodos[from].lng, grafo.nodos[from].lat],
            [grafo.nodos[to].lng, grafo.nodos[to].lat]
        ]
    });

    L.polyline(
        [
            [grafo.nodos[from].lat, grafo.nodos[from].lng],
            [grafo.nodos[to].lat, grafo.nodos[to].lng]
        ],
        {weight:3, opacity:0.8}
    ).addTo(capaSubgrafo);

    selA = null;
    selB = null;

    document.getElementById("pesoBox").style.display = "none";
    document.getElementById("inputPeso").value = "";

    actualizarJson();
});



document.getElementById("cancelEdge").addEventListener("click", () => {
    selA = null;
    selB = null;
    document.getElementById("pesoBox").style.display = "none";
});

document.getElementById("sendGraph").addEventListener("click", async () => {

    if (!origen || !destino) {
        alert("Selecciona origen y destino primero");
        return;
    }

    const payload = {
        grafo: grafo,
        origen: origen,
        destino: destino
    };

    const respDiv = document.getElementById("serverResponse");

    try {
        const res = await fetch("http://127.0.0.1:8000/camino_optimo", {
            method:"POST",
            headers:{ "Content-Type":"application/json" },
            body: JSON.stringify(payload)
        });

        const data = await res.json();
if (!data.ok) {
    alert(data.error);
    return;
}


pintarRuta(data.subgrafo);


respDiv.innerHTML = `
    <div style="padding:8px;border-radius:6px;background:#eef4ff;border:1px solid #aac;">
        <div><b>Flujo máximo:</b> ${data.flujo_maximo}</div>
        <div><b>Camino óptimo:</b> ${data.camino.join(" → ")}</div>
        <div><b>Capacidad total del recorrido:</b> ${data.capacidad_total}</div>
    </div>
`;


    } catch(err) {
        respDiv.innerHTML = "<b style='color:red;'>Error enviando grafo</b>";
        console.error(err);
    }
});


function pintarRuta(sub) {

    capaSubgrafo.clearLayers();

    sub.nodes.forEach(n => {
        L.circleMarker([n.lat, n.lng], {
            radius: 7,
            color: "yellow",
            fillColor: "orange",
            fillOpacity: 1
        }).addTo(capaSubgrafo);
    });

    sub.edges.forEach(e => {
        const coords = e.raw.coordinates;

        L.polyline(
            [
                [coords[0][1], coords[0][0]],
                [coords[1][1], coords[1][0]]
            ],
            { color:"yellow", weight:5 }
        ).addTo(capaSubgrafo);
    });
}

</script>

</body>
</html>
